{"mappings":"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","sources":["<anon>","src/js/index.js"],"sourcesContent":["var $85a5f86b715fe7db$exports = {};\n// // 1 отримали контейнер з HTML\n// const container = document.querySelector('.js-content')\n// // console.log(container);\n// // 2 створюємо гравця Х по дефолту\n// let player = \"X\";\n// // 3 створимо історії ходів двох гравців і їх пусті масиви, які будуть заповнюватися даними\n// // щоб легко було очистити поля задамо змінні через Let а не const\n// let historyX = [];\n// let historyO = [];\n// // 4 створюємо масив масивів всіх виграшних комбінацй\n// const wins = [\n//     [1, 2, 3],\n//     [3, 6, 9],\n//     [4, 5, 6],\n//     [7, 8, 9],\n//     [1, 4, 7],\n//     [2, 5, 8],\n//     [1, 5, 9],\n//     [3, 5, 7],\n// ];\n// //5 Створюємо функцію генерування розмітки\n// //6 створюємо  змінну markup, в яку кожен раз буде додаватися нове поле ігрове div, у якого клас js-item - щоб первірити куди ми клікнули і data-id -щоб записувати історію ходів\n// // і переносимо її функцію createMarkup()\n// // створюємо нову функцию, щоб можна було перевикористовувати, і переносимо дані в неї\n// function createMarkup() {\n//     let markup = \"\";\n//     for (let i = 1; i < 10; i += 1){\n//         markup += `<div class=\"item js-item\" data-id=\"${i}\"></div>`;\n//     }\n//     // console.log(markup);\n//     //7 наповнили наш HTML контейнер квадратиками!!\n//     container.innerHTML = markup;\n// }\n// // і зразу її викликаємо\n// createMarkup();\n// //8 щоб знати, на який квадратик клікаєм на БАТЬКІВСЬКИЙ елемент вішаємо прослуховувача\n// container.addEventListener('click', onClick);\n// function onClick(evt) {\n//     //9 Делегували подій робимо через Деструктуризацію таргета - коли побвачили, що елемент часто повторюється- робимо змінну і прибираємо його з коду\n//     const { target } = evt;\n// // якщо ми клікнули НЕ на квадратик, то одразу виходимо\n// // 10 перевіряємо якщо наш елемент не містить класу \"js-item\" або якщо його текстовий контент зайнятий!!!- то зразу виходимо \n//     if (!target.classList.contains(\"js-item\") || target.textContent) {\n//         return;\n//     }\n//     // а потім другу умову додаємо через або в перший иф\n//     // ця умова не дає змінювати Х на 0 на ОДНІЙ клітинці!!!\n//     // якщо клітинка пуста - дозволяємо хід, якщо зайнята - не дозволяємо\n//     // if (etarget.textContent) {\n//     //     return;\n//     // }\n//     // щоб дізнатись ID клітинки на яку клікнули- шукаємо її номер, зразу для обох ігроків\n//      // але з data atributa  він прийде у форматі рядка, а наші масиви- то числа тому приводимо його до числа \n//     // const { id } = Number(target.dataset); - так не працює, тому змінюємо на \n//     // 11 Дістаємо id кожної клітинки і приводимо його до числа\n//     const  id  = Number(target.dataset.id);\n//     // створимо змінну для переможця\n// let result = false;\n// // 23 робимо змінну на перевірку кількості ходів \n// const isEndGame = historyO.length + historyX.length === 9;\n//     // 12 Ідемо і перевіряємо, якщо поточний гравець здійснив хід- пушим його в історію\n//     // нам треба визначитись, хто робить хід, тому створюємо умову\n//     if (player === \"X\") {\n//         historyX.push(id);\n//         // 13 Змінній result присвоюємо результат виконання функції isWinner\n//         result = isWinner(historyX)\n//     } else {\n//         historyO.push(id);\n//         result = isWinner(historyO)\n//     }\n//       // текстовий контент елемента, по якому клікнули = Х - це перший ход\n//     //   17 перевизначаємо хід для наступного гравця\n//       target.textContent = player;\n//     //   18 якщо результат TRUE - у нас є переможець і ми підставляємо його в результат ${player}\n//     if (result) {\n//         console.log(`Winner is ${player}`);\n//         // 19 і перезавантажуємо гру функцією resetGame(), яка прописана нижче\n//         resetGame();\n//         return;\n//         // 22 якщо переможця немає, але всі клітинки запонились\n//         // перевіряємо кількість ходів і щоб не робити таку довгу умову виносимо цю перевірку в змінну\n//         // а тут тоді перевіряємо на булеве значення\n//     }else if(isEndGame) {\n// console.log(`Try again!`);\n// resetGame();\n// return;\n//     }\n// // отримуємо просто номер  const {id} = target.dataset\n//     // але з data atributa  він прийде у форматі рядка, а наші масиви- то числа \n//     // console.log('X', historyX);\n//     //  console.log('0', history0);\n//     // console.log( isWinner(historyX));\n// //21 якщо переможця не визначено то ми змінюємо чергу ходу\n// //  змінюємо чергу ходу на 0: якщо був Х змінюємо на 0\n// // перевизначаємо player = \n//     player = player === 'X' ? 'O' : 'X';\n//     // currentTarget-батько(весь контейнер\n//     // target-кожен маленький квадратик)\n//     // console.log(evt.currentTarget);\n//     // console.log(evt.target)\n// }\n// // щоб визначити, хто виграв нам потрібно знати ID клітинки!!!\n// // тому ми його додаємо в код вище!\n// // створимо функцію, яка буде перевіряти чи виграв хтось з гравців\n// // порівнювати з виграшими комбінаціями\n// // в функцыю приходить історыя ходів в вигляді масива\n// // 14 в цій функції перевіряємо чи історія ходів є виграшною!\n// function isWinner(arr) {\n// //15 ми  перебираємо масив wins з допомогою методу some\n// // перевіряємо чи є в історії ходів подібна комбінація цифр\n// // 16 наша умова для методу some це результат виконання методу every\n//                     //   [2, 5, 8]\n// return wins.some((item) => item.every(id => arr.includes(id))); \n//                     //every повертає  TRUE тільки якщо ВСІ елементи задовільнили умові\n// }\n// // щоб очищати ігрові поля створимо функцію resetGame і викличемо її в тому разі коли є переможець\n// function resetGame(){\n//     // 20.1 запускає функцію створення розмітки\n//     createMarkup();\n//     // 20.2 визначає пустим масивом історії Х і О\n//     historyX = [];\n//     historyO = [];\n//     // 20.3 повертаемо до початкового плеєра Х\n//     player = \"X\";\n// }\n// майже сталий вираз\n// є функції save, яка відпоавідає за збереження данних та load, яка отримує значення з локалсторідж\n//  ці функції створюються, щоб зберігти час та сили і не повторювати код\n// бо операції з ключами локалсторіджа одні й ті самі\n// const save = (key, value) => {\n//     try {\n//       const serializedState = JSON.stringify(value);\n//       localStorage.setItem(key, serializedState);\n//     } catch (error) {\n//       console.error(\"Set state error: \", error.message);\n//     }\n//   };\n// //   викликаємо цю функцію і передаємо дані для збереження\n// save('TEST:', {name:\"Hello World!!\"});\n// save('TEST1:', \"Hello all the World!!\");\n//   const load = key => {\n//     try {\n//       const serializedState = localStorage.getItem(key);\n//       return serializedState === null ? undefined : JSON.parse(serializedState);\n//     } catch (error) {\n//       console.error(\"Get state error: \", error.message);\n//     }\n//   };\n//   console.log(load('TEST:'));\n//   export default {\n//     save,\n//     load,\n//   };\n// const content = document.querySelector('.content')\n// const restart = document.querySelector('.js-restart');\n// // const winner = document.querySelector('.js-winner');\n// content.insertAdjacentHTML('beforeend', createMarkup())\n// content.addEventListener('click', onClick);\n// restart.addEventListener('click', onRestart);\n// // winner.addEventListener('click', onCurrentWinner);\n// // назви ключів виносяться в змінні, бо до них будемо звертатися декілька разів\n// const KEY_X = 'PlayerX';\n// const KEY_O = 'PlayerO';\n// let player = 'X';\n// // масиви для збереження даних про ходи\n// let stepX = JSON.parse(localStorage.getItem(KEY_X)) || [];\n// let stepO = JSON.parse(localStorage.getItem(KEY_O)) || [];\n// // const WIN_X = 'сurrentWinX';\n// // const WIN_O = 'сurrentWinO';\n// // let сurrentWinX = 0;\n// // let currentWinO = 0;\n// // let winHistory_X = JSON.parse(localStorage.getItem(WIN_X));\n// // let winHistory_O = JSON.parse(localStorage.getItem(WIN_O));\n// const win = [\n//     [1, 2, 3],\n//     [3, 6, 9],\n//     [4, 5, 6],\n//     [7, 8, 9],\n//     [1, 4, 7],\n//     [2, 5, 8],\n//     [1, 5, 9],\n//     [3, 5, 7]\n// ];\n// function startGame() {\n//     // console.dir(content);\n//     // для HTML не приміняється forEach\n//     // console.log(stepX);\n//     // console.log(stepO);\n//     [...content.children].forEach(item => {\n//         const id = Number(item.dataset.id)\n//         // console.log(id);\n//         // console.log(stepX)\n//         // console.log(stepX.includes(id))\n//         if(stepX.includes(id)) {\n//             item.textContent = 'X';\n//         }else if(stepO.includes(id)){\n//             item.textContent = 'O';\n//         }\n//     })\n// }\n// startGame();\n// приклад методів сам і еврі\n// const stepX = [2, 5, 3, 8, 9];\n// const test = [1, 2, 3]\n// // console.log(test.every(id => stepX.includes(id)))\n// const isTrue = test.every(id => stepX.includes(id));\n// // візьмемо наш масив win і подивимось чи ХОТЬ ОДИН його елемент item відповідає\n// console.log(win.some(item => console.log(item)))\n// перебираємо масив win методом some, далі на кожній ітерації some перебираємо масив stepX.push(id); методм every \n// і дивимся, щоб співпали всі числа з виграшною комбінацією\n// метод every потребує щоб співпали всі значення, тільки тоді він видась TRUE\n// function isWinner(arr) {\n//     return win.some(item => item.every(id => arr.includes(id)))\n//     }\n// function createMarkup() {\n//     let markup = '';\n//     for (let i = 1; i <= 9; i += 1)  {\n// markup += `<div class=\"item\" data-id=\"${i}\"></div>`\n//     }\n//     return markup;\n// }\n// function onClick(evt) {\n//     if (!evt.target.textContent) {\n//         evt.target.textContent = player;\n//         // console.dir(evt.target);\n//         const id = Number(evt.target.dataset.id);\n//     //   по дефолту переможця немає\n//         let result;\n//         if(player === \"X\") {\n//             stepX.push(id);\n//             localStorage.setItem(KEY_X, JSON.stringify(stepX));\n//             result = isWinner(stepX);\n//             // winHistory_X = сurrentWinX + 1;\n//             // localStorage.setItem(WIN_X, JSON.stringify(winHistory_X));\n//         }else {\n//             stepO.push(id)\n//             localStorage.setItem(KEY_O, JSON.stringify(stepO));\n//             result = isWinner(stepO);\n//             // winHistory_O = currentWinO + 1;\n//             // localStorage.setItem(WIN_O, JSON.stringify(winHistory_O));\n//         }  \n//       setTimeout(() =>{\n//         if (result) {\n//             alert(`Winner is ${player}`);\n//             // очистити поле після того, як знайшли переможця\n//             onRestart();\n//             return;\n//         }\n//         player = player === \"X\" ? \"0\" : \"X\";   \n//       })\n//     //    console.log('stepX', stepX);\n//     //    console.log('stepO', stepO);\n//     } else {\n//         alert('Change!!!')\n//     }\n// }\n// function onCurrentWinner() {\n// if(winHistory_O < winHistory_X) {\n//     alert(`PlayerX won ${localStorage.getItem(WIN_X)} times`)\n// }else {\n//     alert(`PlayerX won ${localStorage.getItem(WIN_O)} times`)\n// }\n// }\n// function onRestart() {\n//     player = \"X\";\n//     stepX = [];\n//     stepO = [];\n//     localStorage.removeItem('KEY_X')\n//     localStorage.removeItem('KEY_O')\n//     // localStorage.clear()\n//     content.innerHTML = createMarkup();\n// }\n// const session = document.querySelector('.session');\n// const local = document.querySelector('.local');\n// const remove = document.querySelector('.remove');\n// session.addEventListener('click', onSession);\n// const arr =[1,2,3,4,5,]\n// function onSession() {\n//     // sessionStorage.setItem('session', 'hello session');\n//     const data = JSON.parse(localStorage.getItem('local')) || [];\n//     console.log(data);\n//     // якщо це- const arr =[1,2,3,4,5,]-масив то й тут додаємо пустий масив \n//     // const resp = JSON.parse(data)\n//     // console.log(resp);\n//     // sessionStorage.setItem('session', arr);\n//     data.forEach(element => {\n//         console.log(element);\n//     });\n// }\n// local.addEventListener('click', onLocal);\n// function onLocal() {\n//     // приводимо до рядка\n//     localStorage.setItem('local', JSON.stringify(arr));\n//     localStorage.setItem('local1', JSON.stringify(arr));\n//     localStorage.setItem('local2', JSON.stringify(arr));\n// }\n// remove.addEventListener('click', onRemove)\n// function onRemove() {\n// // localStorage.removeItem('local');\n// localStorage.clear();\n// }\n\n\n//# sourceMappingURL=index.894b8c4f.js.map\n","// // 1 отримали контейнер з HTML\n// const container = document.querySelector('.js-content')\n// // console.log(container);\n// // 2 створюємо гравця Х по дефолту\n// let player = \"X\";\n// // 3 створимо історії ходів двох гравців і їх пусті масиви, які будуть заповнюватися даними\n// // щоб легко було очистити поля задамо змінні через Let а не const\n// let historyX = [];\n// let historyO = [];\n// // 4 створюємо масив масивів всіх виграшних комбінацй\n// const wins = [\n//     [1, 2, 3],\n//     [3, 6, 9],\n//     [4, 5, 6],\n//     [7, 8, 9],\n//     [1, 4, 7],\n//     [2, 5, 8],\n//     [1, 5, 9],\n//     [3, 5, 7],\n// ];\n// //5 Створюємо функцію генерування розмітки\n// //6 створюємо  змінну markup, в яку кожен раз буде додаватися нове поле ігрове div, у якого клас js-item - щоб первірити куди ми клікнули і data-id -щоб записувати історію ходів\n// // і переносимо її функцію createMarkup()\n// // створюємо нову функцию, щоб можна було перевикористовувати, і переносимо дані в неї\n// function createMarkup() {\n//     let markup = \"\";\n//     for (let i = 1; i < 10; i += 1){\n//         markup += `<div class=\"item js-item\" data-id=\"${i}\"></div>`;\n//     }\n//     // console.log(markup);\n//     //7 наповнили наш HTML контейнер квадратиками!!\n//     container.innerHTML = markup;\n// }\n// // і зразу її викликаємо\n// createMarkup();\n\n// //8 щоб знати, на який квадратик клікаєм на БАТЬКІВСЬКИЙ елемент вішаємо прослуховувача\n// container.addEventListener('click', onClick);\n\n// function onClick(evt) {\n//     //9 Делегували подій робимо через Деструктуризацію таргета - коли побвачили, що елемент часто повторюється- робимо змінну і прибираємо його з коду\n//     const { target } = evt;\n// // якщо ми клікнули НЕ на квадратик, то одразу виходимо\n// // 10 перевіряємо якщо наш елемент не містить класу \"js-item\" або якщо його текстовий контент зайнятий!!!- то зразу виходимо \n//     if (!target.classList.contains(\"js-item\") || target.textContent) {\n//         return;\n//     }\n//     // а потім другу умову додаємо через або в перший иф\n//     // ця умова не дає змінювати Х на 0 на ОДНІЙ клітинці!!!\n//     // якщо клітинка пуста - дозволяємо хід, якщо зайнята - не дозволяємо\n//     // if (etarget.textContent) {\n//     //     return;\n//     // }\n//     // щоб дізнатись ID клітинки на яку клікнули- шукаємо її номер, зразу для обох ігроків\n//      // але з data atributa  він прийде у форматі рядка, а наші масиви- то числа тому приводимо його до числа \n\n//     // const { id } = Number(target.dataset); - так не працює, тому змінюємо на \n//     // 11 Дістаємо id кожної клітинки і приводимо його до числа\n//     const  id  = Number(target.dataset.id);\n//     // створимо змінну для переможця\n// let result = false;\n// // 23 робимо змінну на перевірку кількості ходів \n// const isEndGame = historyO.length + historyX.length === 9;\n//     // 12 Ідемо і перевіряємо, якщо поточний гравець здійснив хід- пушим його в історію\n//     // нам треба визначитись, хто робить хід, тому створюємо умову\n//     if (player === \"X\") {\n//         historyX.push(id);\n//         // 13 Змінній result присвоюємо результат виконання функції isWinner\n//         result = isWinner(historyX)\n//     } else {\n//         historyO.push(id);\n//         result = isWinner(historyO)\n//     }\n//       // текстовий контент елемента, по якому клікнули = Х - це перший ход\n//     //   17 перевизначаємо хід для наступного гравця\n//       target.textContent = player;\n//     //   18 якщо результат TRUE - у нас є переможець і ми підставляємо його в результат ${player}\n//     if (result) {\n//         console.log(`Winner is ${player}`);\n//         // 19 і перезавантажуємо гру функцією resetGame(), яка прописана нижче\n//         resetGame();\n//         return;\n//         // 22 якщо переможця немає, але всі клітинки запонились\n//         // перевіряємо кількість ходів і щоб не робити таку довгу умову виносимо цю перевірку в змінну\n//         // а тут тоді перевіряємо на булеве значення\n//     }else if(isEndGame) {\n// console.log(`Try again!`);\n// resetGame();\n// return;\n//     }\n// // отримуємо просто номер  const {id} = target.dataset\n//     // але з data atributa  він прийде у форматі рядка, а наші масиви- то числа \n//     // console.log('X', historyX);\n//     //  console.log('0', history0);\n//     // console.log( isWinner(historyX));\n  \n// //21 якщо переможця не визначено то ми змінюємо чергу ходу\n// //  змінюємо чергу ходу на 0: якщо був Х змінюємо на 0\n// // перевизначаємо player = \n//     player = player === 'X' ? 'O' : 'X';\n\n//     // currentTarget-батько(весь контейнер\n//     // target-кожен маленький квадратик)\n//     // console.log(evt.currentTarget);\n//     // console.log(evt.target)\n// }\n// // щоб визначити, хто виграв нам потрібно знати ID клітинки!!!\n// // тому ми його додаємо в код вище!\n\n// // створимо функцію, яка буде перевіряти чи виграв хтось з гравців\n// // порівнювати з виграшими комбінаціями\n// // в функцыю приходить історыя ходів в вигляді масива\n// // 14 в цій функції перевіряємо чи історія ходів є виграшною!\n// function isWinner(arr) {\n// //15 ми  перебираємо масив wins з допомогою методу some\n// // перевіряємо чи є в історії ходів подібна комбінація цифр\n// // 16 наша умова для методу some це результат виконання методу every\n//                     //   [2, 5, 8]\n// return wins.some((item) => item.every(id => arr.includes(id))); \n//                     //every повертає  TRUE тільки якщо ВСІ елементи задовільнили умові\n// }\n\n// // щоб очищати ігрові поля створимо функцію resetGame і викличемо її в тому разі коли є переможець\n// function resetGame(){\n//     // 20.1 запускає функцію створення розмітки\n//     createMarkup();\n//     // 20.2 визначає пустим масивом історії Х і О\n//     historyX = [];\n//     historyO = [];\n//     // 20.3 повертаемо до початкового плеєра Х\n//     player = \"X\";\n// }\n\n\n// майже сталий вираз\n// є функції save, яка відпоавідає за збереження данних та load, яка отримує значення з локалсторідж\n//  ці функції створюються, щоб зберігти час та сили і не повторювати код\n// бо операції з ключами локалсторіджа одні й ті самі\n\n// const save = (key, value) => {\n//     try {\n//       const serializedState = JSON.stringify(value);\n//       localStorage.setItem(key, serializedState);\n//     } catch (error) {\n//       console.error(\"Set state error: \", error.message);\n//     }\n//   };\n  \n// //   викликаємо цю функцію і передаємо дані для збереження\n// save('TEST:', {name:\"Hello World!!\"});\n// save('TEST1:', \"Hello all the World!!\");\n\n//   const load = key => {\n//     try {\n//       const serializedState = localStorage.getItem(key);\n//       return serializedState === null ? undefined : JSON.parse(serializedState);\n//     } catch (error) {\n//       console.error(\"Get state error: \", error.message);\n//     }\n//   };\n  \n//   console.log(load('TEST:'));\n\n//   export default {\n//     save,\n//     load,\n//   };\n\n\n\n// const content = document.querySelector('.content')\n// const restart = document.querySelector('.js-restart');\n// // const winner = document.querySelector('.js-winner');\n// content.insertAdjacentHTML('beforeend', createMarkup())\n// content.addEventListener('click', onClick);\n// restart.addEventListener('click', onRestart);\n// // winner.addEventListener('click', onCurrentWinner);\n// // назви ключів виносяться в змінні, бо до них будемо звертатися декілька разів\n// const KEY_X = 'PlayerX';\n// const KEY_O = 'PlayerO';\n// let player = 'X';\n// // масиви для збереження даних про ходи\n// let stepX = JSON.parse(localStorage.getItem(KEY_X)) || [];\n// let stepO = JSON.parse(localStorage.getItem(KEY_O)) || [];\n\n// // const WIN_X = 'сurrentWinX';\n// // const WIN_O = 'сurrentWinO';\n// // let сurrentWinX = 0;\n// // let currentWinO = 0;\n\n// // let winHistory_X = JSON.parse(localStorage.getItem(WIN_X));\n// // let winHistory_O = JSON.parse(localStorage.getItem(WIN_O));\n\n// const win = [\n//     [1, 2, 3],\n//     [3, 6, 9],\n//     [4, 5, 6],\n//     [7, 8, 9],\n//     [1, 4, 7],\n//     [2, 5, 8],\n//     [1, 5, 9],\n//     [3, 5, 7]\n// ];\n\n// function startGame() {\n//     // console.dir(content);\n//     // для HTML не приміняється forEach\n//     // console.log(stepX);\n//     // console.log(stepO);\n//     [...content.children].forEach(item => {\n//         const id = Number(item.dataset.id)\n//         // console.log(id);\n//         // console.log(stepX)\n//         // console.log(stepX.includes(id))\n//         if(stepX.includes(id)) {\n//             item.textContent = 'X';\n//         }else if(stepO.includes(id)){\n//             item.textContent = 'O';\n\n//         }\n//     })\n// }\n// startGame();\n\n// приклад методів сам і еврі\n// const stepX = [2, 5, 3, 8, 9];\n// const test = [1, 2, 3]\n// // console.log(test.every(id => stepX.includes(id)))\n// const isTrue = test.every(id => stepX.includes(id));\n// // візьмемо наш масив win і подивимось чи ХОТЬ ОДИН його елемент item відповідає\n// console.log(win.some(item => console.log(item)))\n\n\n// перебираємо масив win методом some, далі на кожній ітерації some перебираємо масив stepX.push(id); методм every \n// і дивимся, щоб співпали всі числа з виграшною комбінацією\n// метод every потребує щоб співпали всі значення, тільки тоді він видась TRUE\n// function isWinner(arr) {\n//     return win.some(item => item.every(id => arr.includes(id)))\n//     }\n    \n// function createMarkup() {\n//     let markup = '';\n//     for (let i = 1; i <= 9; i += 1)  {\n// markup += `<div class=\"item\" data-id=\"${i}\"></div>`\n//     }\n//     return markup;\n// }\n\n// function onClick(evt) {\n\n//     if (!evt.target.textContent) {\n//         evt.target.textContent = player;\n//         // console.dir(evt.target);\n//         const id = Number(evt.target.dataset.id);\n//     //   по дефолту переможця немає\n//         let result;\n//         if(player === \"X\") {\n//             stepX.push(id);\n//             localStorage.setItem(KEY_X, JSON.stringify(stepX));\n//             result = isWinner(stepX);\n//             // winHistory_X = сurrentWinX + 1;\n//             // localStorage.setItem(WIN_X, JSON.stringify(winHistory_X));\n           \n//         }else {\n//             stepO.push(id)\n//             localStorage.setItem(KEY_O, JSON.stringify(stepO));\n//             result = isWinner(stepO);\n//             // winHistory_O = currentWinO + 1;\n//             // localStorage.setItem(WIN_O, JSON.stringify(winHistory_O));\n//         }  \n//       setTimeout(() =>{\n//         if (result) {\n//             alert(`Winner is ${player}`);\n//             // очистити поле після того, як знайшли переможця\n//             onRestart();\n//             return;\n//         }\n//         player = player === \"X\" ? \"0\" : \"X\";   \n//       })\n     \n//     //    console.log('stepX', stepX);\n//     //    console.log('stepO', stepO);\n           \n//     } else {\n//         alert('Change!!!')\n//     }\n// }\n\n// function onCurrentWinner() {\n// if(winHistory_O < winHistory_X) {\n//     alert(`PlayerX won ${localStorage.getItem(WIN_X)} times`)\n// }else {\n//     alert(`PlayerX won ${localStorage.getItem(WIN_O)} times`)\n// }\n   \n// }\n\n// function onRestart() {\n//     player = \"X\";\n//     stepX = [];\n//     stepO = [];\n//     localStorage.removeItem('KEY_X')\n//     localStorage.removeItem('KEY_O')\n//     // localStorage.clear()\n//     content.innerHTML = createMarkup();\n// }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// const session = document.querySelector('.session');\n// const local = document.querySelector('.local');\n// const remove = document.querySelector('.remove');\n\n// session.addEventListener('click', onSession);\n// const arr =[1,2,3,4,5,]\n// function onSession() {\n//     // sessionStorage.setItem('session', 'hello session');\n//     const data = JSON.parse(localStorage.getItem('local')) || [];\n//     console.log(data);\n//     // якщо це- const arr =[1,2,3,4,5,]-масив то й тут додаємо пустий масив \n//     // const resp = JSON.parse(data)\n//     // console.log(resp);\n//     // sessionStorage.setItem('session', arr);\n\n//     data.forEach(element => {\n//         console.log(element);\n//     });\n// }\n\n// local.addEventListener('click', onLocal);\n\n// function onLocal() {\n//     // приводимо до рядка\n//     localStorage.setItem('local', JSON.stringify(arr));\n//     localStorage.setItem('local1', JSON.stringify(arr));\n//     localStorage.setItem('local2', JSON.stringify(arr));\n// }\n\n// remove.addEventListener('click', onRemove)\n\n// function onRemove() {\n// // localStorage.removeItem('local');\n// localStorage.clear();\n// }\n"],"names":[],"version":3,"file":"index.894b8c4f.js.map"}